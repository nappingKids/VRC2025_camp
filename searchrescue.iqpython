{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\noptical_4 = Optical(Ports.PORT4)\nleft_motor = Motor(Ports.PORT2, False)\nright_motor = Motor(Ports.PORT1, True)\nforklift = Motor(Ports.PORT7, False)\ndistance_12 = Distance(Ports.PORT12)\n\n\n\n# generating and setting random seed\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    systemTime = brain.timer.system() * 100\n    urandom.seed(int(xaxis + yaxis + zaxis + systemTime)) \n    \n# Initialize random seed \ninitializeRandomSeed()\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n# \tAuthor:       VEX\n# \tCreated:\n# \tDescription:  VEXcode IQ Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n# Begin project code\nstate = \"SETUP\"\n\ndef turn_left(degrees):\n    if degrees == 0:\n        left_motor.spin(REVERSE)\n        right_motor.spin(FORWARD)\n    curr_angle = brain_inertial.heading()\n    target_angle = curr_angle - degrees\n    if target_angle < 0:\n        target_angle += 360\n\n    # Turn left until current angle reaches target angle\n    while True:\n        curr_angle = brain_inertial.heading()\n        # Check if we've reached or passed the target\n        if (curr_angle - target_angle + 360) % 360 < 2:  # Allow 2° tolerance\n            break\n        left_motor.spin(REVERSE)\n        right_motor.spin(FORWARD)\n        wait(20, MSEC)\n\n    left_motor.stop()\n    right_motor.stop()\n    wait(20, MSEC)\n\ndef turn_right(degrees):\n    if degrees == 0:\n        left_motor.spin(FORWARD)\n        right_motor.spin(REVERSE)\n    else:\n        curr_angle = brain_inertial.heading()\n        target_angle = (curr_angle + degrees) % 360\n\n        while True:\n            curr_angle = brain_inertial.heading()\n            # Check if we've reached the target (handle wrap-around)\n            if (target_angle - curr_angle + 360) % 360 < 2:  # 2° tolerance\n                break\n            left_motor.spin(FORWARD)\n            right_motor.spin(REVERSE)\n            wait(20, MSEC)\n\n        left_motor.stop()\n        right_motor.stop()\n        wait(20, MSEC)\n\ndef turn_to_angle(angle):\n    curr_angle = brain_inertial.heading()\n    while (curr_angle > angle):\n        curr_angle = brain_inertial.heading()\n        left_motor.spin(REVERSE)\n        right_motor.spin(FORWARD)\n        wait(20, MSEC)\n\n\ndef do_setup():\n    global state\n    brain_inertial.calibrate()\n    while brain_inertial.is_calibrating():\n        wait(100, MSEC)\n    brain_inertial.set_heading(0, DEGREES)\n    state = \"TRAVEL\"\n\n\ndef do_travel():\n    global state\n    front_distance = distance_12.object_distance(MM)\n    while distance_12.is_object_detected() and front_distance > 200:\n        front_distance = distance_12.object_distance(MM)\n        error = brain_inertial.heading()\n        kp = 2.0\n        if error > 180:\n            error = error - 360\n        output = kp * error\n        left_motor.set_velocity(50 - output)\n        right_motor.set_velocity(50 + output)\n        left_motor.spin(FORWARD)\n        right_motor.spin(FORWARD)\n        wait(20, MSEC)\n    left_motor.stop()\n    right_motor.stop()\n\n    state = \"SEARCH\"\n\ndef do_search():\n    global state\n    left_motor.set_velocity(5, PERCENT)\n    left_motor.set_velocity(5, PERCENT)\n\n\n    # turn 45 degrees left\n    turn_left(45)\n\n    # Turn right 90 degrees and scan for the closest object\n    min_dist = 9999\n    min_angle = -1\n\n    # Get current heading (0–360)\n    start_angle = brain_inertial.heading()\n\n    # Calculate target heading with wrap-around\n    target_angle = (start_angle + 90) % 360\n\n    while True:\n        curr_angle = brain_inertial.heading()\n\n        # Check if we’ve completed the 90° turn\n        # (curr_angle - start_angle + 360) % 360 handles wrap-around safely\n        if (curr_angle - start_angle + 360) % 360 >= 90:\n            break\n\n        # Measure distance\n        curr_dist = distance_12.object_distance(MM)\n        if curr_dist < min_dist:\n            min_dist = curr_dist\n            min_angle = curr_angle\n\n        # Keep turning right in place\n        left_motor.spin(FORWARD)\n        right_motor.spin(REVERSE)\n\n        wait(20, MSEC)\n\n    # Stop after turning 90°\n    left_motor.stop()\n    right_motor.stop()\n\n    # Function to turn robot to a specific heading (0–360)\n    def turn_to_angle(target_angle):\n        while True:\n            curr = brain_inertial.heading()\n            diff = (target_angle - curr + 360) % 360\n            if diff < 2 or diff > 358:  # within ~2°\n                break\n            if diff < 180:\n                left_motor.spin(FORWARD)\n                right_motor.spin(REVERSE)\n            else:\n                left_motor.spin(REVERSE)\n                right_motor.spin(FORWARD)\n            wait(20, MSEC)\n        left_motor.stop()\n        right_motor.stop()\n\n    # Go back to the heading with the closest object\n    if min_angle != -1:\n        turn_to_angle(min_angle)\n\n    state = \"FORK\"\n \n    # optical_4.set_light(LedStateType.ON)\n    # optical_4.set_light_power(100, PERCENT)\n    # if (optical_4.color() == Color.BLUE):\n    #     brain.screen.next_row()\n    #     brain.screen.print(\"BLUE!\")\n    # if (optical_4.color() == Color.CYAN):\n    #     brain.screen.next_row()\n    #     brain.screen.print(\"CYAN!\")\n    # if (optical_4.color() == Color.RED):\n    #     brain.screen.next_row()\n    #     brain.screen.print(\"RED!\")\n    # if (optical_4.color() == Color.ORANGE):\n    #     brain.screen.next_row()\n    #     brain.screen.print(\"ORANGE!\")\n    # if (optical_4.color() == Color.YELLOW):\n    #     brain.screen.next_row()\n    #     brain.screen.print(\"YELLOW!\")\n\n    # wait(100, MSEC)\n\ndef do_fork():\n    global state\n    curr_dist = distance_12.object_distance(MM)\n    while curr_dist > 50:\n        left_motor.spin(FORWARD)\n        right_motor.spin(FORWARD)\n\n        wait(20, MSEC)\n        curr_dist = distance_12.object_distance(MM)\n    \n    left_motor.stop()\n    right_motor.stop()\n    state = \"LIFT\"\n\ndef do_lift():\n    pass\n\ndef do_base():\n\n    global state\n    pass\n\ndef do_avoid():\n\n    global state\n    pass\n\n\n\nwhile True:\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1,1)\n    brain.screen.print(\"STATE\", state)\n\n    if state == \"SETUP\":\n        do_setup()\n        continue\n    if state == \"TRAVEL\":\n        do_travel()\n        continue\n    if state == \"SEARCH\":\n        do_search()\n        continue\n\n    if state == \"FORK\":\n        do_fork()\n        continue\n    if state == \"LIFT\":\n        do_lift()\n        continue\n    if state == \"BASE\":\n        do_base()\n        continue\n    if state == \"AVOID\":\n        do_avoid()\n        continue\n\n","textLanguage":"python","robotConfig":["port":[4],"name":"optical_4","customName":false,"deviceType"{:"Optical","deviceClass":"optical","setting":{},"triportSourcePort":22},{"port":[2],"name":"left_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[1],"name":"right_motor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[7],"name":"forklift","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"distance_12","customName":false,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false}
Nathan